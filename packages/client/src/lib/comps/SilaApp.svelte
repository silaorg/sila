<script lang="ts">
  import { onMount, onDestroy, type Snippet } from "svelte";
  import { type ClientStateConfig } from "@sila/client";
  import ClientStateProvider from "@sila/client/comps/ClientStateProvider.svelte";
  import { ClientState } from "@sila/client";
  import { isDevMode, readEnv } from "@sila/core";
  import SpaceEntry from "./SpaceEntry.svelte";
  import SwinsContainer from "../swins/SwinsContainer.svelte";
  import ContextMenuHandler from "./ContextMenuHandler.svelte";
  import ThemeManager from "./themes/ThemeManager.svelte";
  import GlobalKeyHandlers from "./GlobalKeyHandlers.svelte";

  // ./lib/compiled-style.css should be generated by Tailwind; this import ensures styles are present
  import "@sila/client/compiled-style.css";
  // KaTeX CSS must be imported from JS so Vite bundles KaTeX fonts in desktop/mobile builds.
  import "katex/dist/katex.min.css";
  import Toasts from "./ui/Toasts.svelte";
  import VertexViewerModal from "./vertex-viewer/VertexViewerModal.svelte";

  let {
    config,
    state: initialState,
    chromeTop,
    children,
  }: {
    config: ClientStateConfig | null;
    state?: ClientState;
    chromeTop?: Snippet;
    children?: Snippet;
  } = $props();

  const providedState = $derived(initialState || new ClientState());

  // Height (in px) of optional wrapper chrome rendered above the app content.
  // Used to offset fixed-position UI (e.g., hover sidebar) in a platform-agnostic way.
  let chromeTopEl: HTMLDivElement | null = $state(null);
  let chromeTopHeightPx: number = $state(0);

  $effect(() => {
    if (!chromeTop || !chromeTopEl) {
      chromeTopHeightPx = 0;
      return;
    }

    const el = chromeTopEl;
    const update = () => {
      chromeTopHeightPx = Math.round(el.getBoundingClientRect().height);
    };

    update();

    if (typeof ResizeObserver === "undefined") return;
    const ro = new ResizeObserver(() => update());
    ro.observe(el);
    return () => ro.disconnect();
  });

  const defaultTelemetryConfig = $derived.by(
    (): ClientStateConfig["telemetryConfig"] => {
      const apiKeyBase = "POSTHOG_API_KEY";
      const hostKeyBase = "POSTHOG_API_HOST";

      const apiKey = readEnv(apiKeyBase);
      const host = readEnv(hostKeyBase);

      if (!apiKey || !host) {
        console.error("Analytics not configured: missing env vars");
        return undefined;
      }

      return {
        apiKey,
        host,
        debug: isDevMode(),
      };
    }
  );

  const resolvedConfig = $derived.by(() => {
    if (!config) return null;
    return {
      ...config,
      telemetryConfig: config.telemetryConfig
        ? config.telemetryConfig
        : defaultTelemetryConfig,
    };
  });

  function getViteAppVersion(): string {
    return (
      (typeof import.meta !== "undefined" &&
        (import.meta as any).env?.VITE_APP_VERSION) ||
      (typeof process !== "undefined" &&
        (process as any).env?.VITE_APP_VERSION) ||
      "dev"
    );
  }

  async function resolveAppVersions(
    cfg: ClientStateConfig
  ): Promise<ClientStateConfig["appVersions"]> {
    if (cfg.appVersions) return cfg.appVersions;

    const efs =
      typeof window !== "undefined" ? (window as any).electronFileSystem : null;
    if (efs?.getAppVersions) {
      try {
        return await efs.getAppVersions();
      } catch (e) {
        console.error("Failed to load app versions from Electron", e);
      }
    }

    return {
      shell: null,
      client: { version: getViteAppVersion(), source: "client" },
    };
  }

  // Keep startup non-blocking: init immediately, then populate version info in the background.
  // Use plain flags (not `$state`) to guarantee we don't accidentally start multiple concurrent inits.
  let didInit = false;
  let didResolveVersions = false;

  $effect(() => {
    if (!resolvedConfig) return;

    if (!didInit) {
      didInit = true;
      providedState.init(resolvedConfig);

      console.log(
        "ðŸ‘‹ Report bugs here: https://github.com/silaorg/sila/issues"
      );
      console.log(
        "Reach out to the author of the project with any questions - Dmitry at d@dkury.com"
      );
    }

    if (!didResolveVersions) {
      didResolveVersions = true;
      resolveAppVersions(resolvedConfig).then((appVersions) => {
        providedState.appVersions = appVersions ?? null;

        console.log("App versions\n", JSON.stringify(appVersions, null, 2));
      });
    }
  });

  onMount(() => {
    return () => {};
  });

  onDestroy(() => {
    providedState.cleanup();
  });
</script>

{#if resolvedConfig}
  <ClientStateProvider instance={providedState}>
    <!-- Global key handlers -->
    <GlobalKeyHandlers />

    <!-- Set a current theme and a color scheme -->
    <ThemeManager />

    <div style={`--sila-chrome-top: ${chromeTopHeightPx}px;`}>
      <!-- Optional wrapper chrome (desktop/mobile/web shells) -->
      {#if chromeTop}
        <div bind:this={chromeTopEl}>
          {@render chromeTop?.()}
        </div>
      {/if}

      <!-- Where our spaces are rendered -->
      <SpaceEntry />

      <!-- Setup stacking windows (popover windows with navigation) we use for new conversations, settings, etc -->
      <SwinsContainer />

      <!-- Handle native and custom context menus -->
      <ContextMenuHandler />

      <!-- Setup toasts for notifications -->
      <Toasts />

      <!-- A modal for viewing vertices that reference files, such as images, videos, PDFs, etc -->
      <VertexViewerModal />

      <!-- Render whatever components passed from the wrappers of SilaApp (e.g Desktop, Mobile, etc)-->
      {@render children?.()}
    </div>
  </ClientStateProvider>
{:else}
  Loading...
{/if}
